<h1>BPFd: Running BCC tools remotely across systems and architectures</h1>

<h2>Introduction</h2>

<p><a href="https://github.com/iovisor/bcc/blob/master/README.md">BCC tools</a> are a suite of kernel tracing tools that allow systems engineers to efficiently and safely get a deep understanding into the inner workings of a Linux system. Because they can&rsquo;t crash the kernel, they are safer than kernel modules and are also can be used in production. <a href="http://www.brendangregg.com/ebpf.html">Brendan Gregg has written</a> several nice tools, and talks in videos showing the full power of eBPF based tools.</p>

<p>In the Android kernel team, we work mostly on ARM64 systems since most Android devices are on this architecture. BCC tools support on ARM64 systems had been broken for years. Recently this got <a href="https://github.com/iovisor/bcc/issues/1202">fixed</a> and one could run the tools but..</p>

<p>Inorder for BCC tools to work at all, they need kernel sources. This is because most tools need to register callbacks on the ever changing kernel API inorder to get their data. Such callbacks are registered using the <a href="https://lwn.net/Articles/132196/">kprobe</a> infrastructure. Kernel sources are large in size and often can take up a large amount of space on the system being debugged. They can also get out of sync which may make the tools misbehave.</p>

<p>The other issue is Clang and LLVM libraries need to be available on the target being traced. This is because the tools compile the needed BPF bytecode which are then loaded into the kernel. These libraries take up a lot space. It seems overkill you need a full blown compiler infrastructure on a system when the BPF code can be compiled elsewhere and maybe even compiled just once. Further these libraries need to be cross-compiled to run on the architecture you&rsquo;re tracing. That&rsquo;s possible, but why would anyone want to do that if they didn&rsquo;t need to? Cross-compiling compiler toolchains can be tedious and stressful.</p>

<h2>BPFd: A daemon for BPF code and commands</h2>

<p><a href="https://github.com/joelagnel/bpfd">Sources for BPFd can be downloaded here</a>.</p>

<p>Instead of loading up all the tools, compiler infrastructure and kernel sources onto the targets being traced, I decided to write a proxy program named BPFd that would receive commands and perform them on behalf of whoever is requesting them. The program would encapsulate all the needs of BCC and perform them &ndash; this includes loading a BPF program, creating, deleting and looking up maps, attaching a BPF program to a kprobe, polling for new data that the BPF may have written into a perf buffer etc.</p>

<h3>Simple design</h3>

<p>The design of BPFd is quite simple, it expects commands on <code>stdin</code> (standard input) and provides the results over <code>stdout</code> (standard output). Every command is only a single line always, no matter how big the command is. This allows easy testing using <code>cat</code>, since one could simply <code>cat</code> a file with commands, and parse whether the results are as expected. Results from a command however can be multiple lines.</p>

<p>For example, following is a command to BPFd for creating a BPF map:
  BPF_CREATE_MAP 1 count 8 40 10240 0</p>

<p>And the result from BPFd is:
  bpf_create_map: ret=3</p>

<p>The command tells BPFd to create a map named <code>count</code> with map type 1, with a key size of 6 bytes and a value size of 40, maximum of 10240 entries and no special flags. In return, BPFd created a map which is identified by file descriptor 3.</p>

<p>With the simple standard input/output design, its possible to write wrappers around BPFd to handle more advanced communication such as USB or Networking. In Android, we are going to be communicating these commands over the USB-based <a href="https://developer.android.com/studio/command-line/adb.html">Android Debug Bridge</a>.</p>

<h3>Changes to BCC tools</h3>

<p><a href="https://github.com/joelagnel/bcc/tree/bcc-bpfd">Branch with latest changes to BCC tools</a></p>

<p>A new <code>remotes</code> module has been added to BCC tools with an abstraction that different remote mechanisms should adhere to. This keeps code duplication to a minimum. Currently an <code>adb</code> remote and a <code>process</code> remote have been added.  The <code>adb</code> remote is for communication with the target device over USB or WiFi using the <a href="https://developer.android.com/studio/command-line/adb.html">Android Debug Bridge</a>. The <code>process</code> remote is for local testing. With this remote, BPFd is forked on the same machine running BCC and communicates with it over <code>stdin</code> and <code>stdout</code>.</p>

<p>BCC tools modifications involve the following changes:
&ndash; Adding support for remote communication with BPFd such as adb
&ndash; Changes to BCC to send commands to the remote system
&ndash; Making the kernel build more configurable so that kernel source and target architecture information can be passed through environment variables.
&ndash; Changes to tools to accomodate the differences
&ndash; Some bug fixes</p>

<h3>Installation procedure: Trying this work out for yourself!</h3>

<p>If you want to just see examples of the results of running these tools, <a href="#running-filetop">you could jump</a> straight to the tools section.
This is just an example of a typical installation procedure, it should be fairly straight forward to get these steps working for other remotes or architectures. For this example, we&rsquo;ll refer to the machine where you do all your development and have your kernel sources available as the <code>development machine</code> and the machine you&rsquo;re tracing as the <code>target</code>.</p>

<h4>Install BCC tools on your development host</h4>

<p>Follow the <a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md">steps here</a> to get BCC tools installed on your development machine.</p>

<p>Except for the following changes:
&ndash; Build BCC <a href="https://github.com/joelagnel/bcc/tree/bcc-bpfd">using this branch</a>
&ndash; Read the section &ldquo;Build LLVM and Clang development libs&rdquo; in that document. Unfortunately BPF inline-assembler support in LLVM is fairly recent, so you may need to build your own LLVM till then. Once LLVM is built, add <code>&lt;path-to-llvm-source&gt;/build/bin/</code> to your <code>$PATH</code> and then build BCC.</p>

<h4>Build/Install BPFd on your target machine</h4>

<p><a href="https://github.com/joelagnel/bpfd">Clone and build the BPFd sources.</a>. This really depends on the target distro, typically you can store it anywere <code>$PATH</code> on the target can find it, in Android we store it in <code>/data/</code> for now. In the future we&rsquo;d want to store it in /system/bin/ once its an official Android package.</p>

<h4>Prepare your kernel sources</h4>

<ul>
<li>Make sure the kernel sources are available on your development machine somewhere, and that the kernel build has completed atleast once in the kernel source directory.</li>
</ul>


<h4>Setup environment variables and run tools</h4>

<p>The following environment variables need to be setup:
&ndash; <code>ARCH</code> should point to the architecture of the <code>target</code> such as <code>x86</code> or <code>arm64</code>.
&ndash; <code>BCC_KERNEL_SOURCE</code> should point to the kernel source directory.
&ndash; <code>BCC_REMOTE</code> should point to the remote mechanism such as <code>adb</code>.</p>

<p>Two example enviornment variable settings are provided which can be sourced. Here&rsquo;s one for <a href="https://github.com/joelagnel/bcc/blob/bcc-bpfd/arm64-adb.rc">adb interface with an arm64 Android target</a> and another one for a <a href="https://github.com/joelagnel/bcc/blob/bcc-bpfd/x86-local.rc">local x86 target with a process remote</a>.</p>

<h3>BPF Demos: examples of different BCC tools running on Android</h3>

<h4>Running filetop</h4>

<p><code>filetop</code> is a BCC tool which shows you all read/write I/O operations with a similar experience to the <code>top</code> tool. In refreshes every few seconds giving you a live view of these operations.
Goto your bcc directory and set the env variables needed. For Android running on Hikey960, I run:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>joel@ubuntu:~/bcc# source arm64-adb.rc</span></code></pre></td></tr></table></div></figure>


<p>which basically sets the following environment variables:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  export ARCH=arm64
</span><span class='line'>  export BCC_KERNEL_SOURCE=/home/joel/sdb/hikey-kernel/
</span><span class='line'>  export BCC_REMOTE=adb</span></code></pre></td></tr></table></div></figure>


<p>Next I start <code>filetop</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>joel@ubuntu:~/bcc# ./tools/filetop.py 5</span></code></pre></td></tr></table></div></figure>


<p>This tells the tool to monitor file I/O every 5 seconds.</p>

<p>While <code>filetop</code> is running, I start the stock email app in Android and the output looks like:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  Tracing... Output every 5 secs. Hit Ctrl-C to end
</span><span class='line'>  13:29:25 loadavg: 0.33 0.23 0.15 2/446 2931
</span><span class='line'> 
</span><span class='line'>  TID    COMM             READS  WRITES R_Kb    W_Kb    T FILE
</span><span class='line'>  3787   Binder:2985_8    44     0      140     0       R profile.db
</span><span class='line'>  3792   m.android.email  89     0      130     0       R Email.apk
</span><span class='line'>  3813   AsyncTask #3     29     0      48      0       R EmailProvider.db
</span><span class='line'>  3808   SharedPreferenc  1      0      16      0       R AndroidMail.Main.xml
</span><span class='line'>  3811   SharedPreferenc  1      0      16      0       R UnifiedEmail.xml
</span><span class='line'>  3792   m.android.email  2      0      16      0       R deviceName
</span><span class='line'>  3815   SharedPreferenc  1      0      16      0       R MailAppProvider.xml
</span><span class='line'>  3813   AsyncTask #3     8      0      12      0       R EmailProviderBody.db
</span><span class='line'>  3809   AsyncTask #1     8      0      12      0       R suggestions.db
</span><span class='line'>  2434   WifiService      4      0      4       0       R iface_stat_fmt
</span><span class='line'>  2434   WifiService      4      0      4       0       R iface_stat_fmt
</span><span class='line'>  3792   m.android.email  66     0      2       0       R framework-res.apk</span></code></pre></td></tr></table></div></figure>


<p>Notice the Email.apk being read by Android to load the email application, and then various other reads happening related to the email app. Finally, WifiService continously reads iface_state_fmt to get network statistics for Android accounting.</p>

<h4>Running biosnoop</h4>

<p>Biosnoop is another great tool shows you block level I/O operations (bio) happening on the system along with the latency and size of the operation. Following is a sample output of running <code>tools/biosnoop.py</code> while doing random things in the Android system.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  TIME(s)        COMM           PID    DISK    T  SECTOR    BYTES   LAT(ms)
</span><span class='line'>  0.000000000    jbd2/sdd13-8   2135   sdd     W  37414248  28672      1.90
</span><span class='line'>  0.001563000    jbd2/sdd13-8   2135   sdd     W  37414304  4096       0.43
</span><span class='line'>  0.003715000    jbd2/sdd13-8   2135   sdd     R  20648736  4096       1.94
</span><span class='line'>  5.119298000    kworker/u16:1  3848   sdd     W  11968512  8192       1.72
</span><span class='line'>  5.119421000    kworker/u16:1  3848   sdd     W  20357128  4096       1.80
</span><span class='line'>  5.119443000    kworker/u16:1  3848   sdd     W  24551552  4096       1.82
</span><span class='line'>  5.119462000    kworker/u16:1  3848   sdd     W  24551680  4096       1.82
</span><span class='line'>  5.119478000    kworker/u16:1  3848   sdd     W  24617256  4096       1.83
</span><span class='line'>  5.448831000    SettingsProvid 2415   sdd     W  20648752  8192       1.70</span></code></pre></td></tr></table></div></figure>


<h4>Running hardirq</h4>

<p>This tool measures the total time taken by different hardirqs in the systems. excessive time spent in hardirq can result in poor real-time performance of the system</p>

<pre><code>joel@ubuntu:~/bcc# ./tools/hardirqs.py
</code></pre>

<p>Output:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  Tracing hard irq event time... Hit Ctrl-C to end.
</span><span class='line'>  HARDIRQ                    TOTAL_usecs
</span><span class='line'>  wl18xx                             232
</span><span class='line'>  dw-mci                            1066
</span><span class='line'>  e82c0000.mali                     8514
</span><span class='line'>  kirin                             9977
</span><span class='line'>  timer                            22384</span></code></pre></td></tr></table></div></figure>


<h4>Running biotop</h4>

<p>Run biotop while launching the android Gallery app and doing random stuff:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>joel@ubuntu:~/bcc# ./tools/biotop.py</span></code></pre></td></tr></table></div></figure>


<p>Output:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PID    COMM             D MAJ MIN DISK       I/O  Kbytes  AVGms
</span><span class='line'>4524   droid.gallery3d  R 8   48  ?           33    1744   0.51
</span><span class='line'>2135   jbd2/sdd13-8     W 8   48  ?           15     356   0.32
</span><span class='line'>4313   kworker/u16:4    W 8   48  ?           26     232   1.61
</span><span class='line'>4529   Jit thread pool  R 8   48  ?            4     184   0.27
</span><span class='line'>2135   jbd2/sdd13-8     R 8   48  ?            7      68   2.19
</span><span class='line'>2459   LazyTaskWriterT  W 8   48  ?            3      12   1.77
</span><span class='line'>2457   TaskSnapshotPer  W 8   48  ?            3      12   1.72
</span><span class='line'>4541   GLThread 152     R 8   48  ?            1       4   1.81
</span><span class='line'>4545   Error dump: sys  W 8   48  ?            1       4   1.70</span></code></pre></td></tr></table></div></figure>


<h3>Open issues as of this writing</h3>

<p>While most issues have been fixed, a few remain. Patches and testing are welcomed!
Following is an incomplete list:
&ndash; cachetop doesn&rsquo;t show hits/misses counter on arm64
&ndash; syscount reads <code>comm_for_pid</code> locally, instead of on the remote.
&ndash; Issues with stacktrace based tools:
  &ndash; offcputime on arm64 shows &ldquo;unknown&rdquo; from the stack trace.
  &ndash; getting tonnes of stack traces is still slow &ndash; possible fix is to dump entire map remotely and send it at once instead of individually sending each key/value as a separate command.</p>

<h3>Conclusion and word on similiarity to SystemTap:</h3>

<p>Building code for instrumentation on a different machine is beneficial and BPFd makes this possible. Tools like <a href="https://sourceware.org/systemtap/">SystemTap</a> have a similar feature. With SystemTap, one can build a kernel module containing the instrumentation/probing code  using the SystemTap scripting language. There&rsquo;s a <code>stap</code> command for that, and then the kernel module is copied over to the target and run using the <code>staprun</code>. However this is quite unsafe since kernel modules can crash the kernel. Further more, the stap scripting language is quite limited in comparison to the eBPF programs written in C. BCC tools are the future of such deep tracing endeavours.</p>
