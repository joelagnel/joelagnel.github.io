
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>LinuxInternals.org</title>
  <meta name="author" content="Joel Fernandes">

  
  <meta name="description" content="Userspace program when compiled to native can place tracepoints in them using a USDT (User Statically Defined Tracing), the details of the &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.linuxinternals.org">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="LinuxInternals.org" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-50777115-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><div>
<div style="margin-right:50px;float:left;">
  <h1><a href="/">LinuxInternals.org</a></h1>
  
    <h2>by Joel Fernandes</h2>
  
</div>
<div style="float:left;" class="hnav">
 <a href="/joel">About me</a><br>
 <a href="/blog/archives/">Articles</a><br>
 <a href="/resources">Talks and resources</a><br>
</div>
<div style="float:right;">
<img src="/images/peng.png" height=150 width=150>
</div>

<div style="position:absolute; top: 170px" class="hnavtitle">
<a>Bits about inner workings of Linux</a>
<!-- a href="http://www.meetup.com/LinuxInternals-org-Embedded-Linux-Training/">Join the internals meetup! -->
<!-- a href="http://www.meetup.com/LinuxInternals-org-Embedded-Linux-Training/">Join the internals meetup! -->
</div>
</div>

</header>
<!--
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.linuxinternals.org" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/technical-resources/">Resources</a></li>
  <li><a href="/aboutme/">About me</a></li>
</ul>

</nav>
-->
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/02/10/usdt-notes/">USDT for Reliable Userspace Event Tracing</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2018-02-10T23:22:39-08:00" pubdate data-updated="true">Feb 10<span>th</span>, 2018</time>
        
           | <a href="/blog/2018/02/10/usdt-notes/#disqus_thread"
             data-disqus-identifier="http://www.linuxinternals.org/blog/2018/02/10/usdt-notes/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Userspace program when compiled to native can place tracepoints in them using a USDT (User Statically Defined Tracing), the details of the tracepoints (such as address and arguments) are placed as a note in the ELF binary for other tools to interpret. This at first seems much better than using Uprobes directly on userspace functions, since the latter not only needs symbol information from the binary but is also at the mercy of compiler optimizations and function inlining. In Android we directly write into <code>tracing_mark_write</code> for userspace tracepoints. While this has its advantages (simplicity), it also means that the only way to &ldquo;process&rdquo; the trace information for ALL tracing usecases is by reading back the trace buffer to userspace and processing them offline, thus needing a full user-kernel-user round trip. Further its not possible to easily create triggers on these events (dump the stack or stop tracing when an event fires, for example). Uprobes event tracing on the other hands gets the full benefit that ftrace events do. Also all userspace emitted trace data is a string which has to be parsed and post-processed. USDT seems a nice way to solve some of these problems, since we can then use the user-provided data and create Uprobes at the correct locations, and process these on the fly using BCC without things ever hitting the trace buffer or returning to userspace.</p>

<p>This simple article is based on some notes I made while playing with USDT probes. To build a C program with an SDT probe, you can just include <code>sdt.h</code> and <code>sdt-config.h</code> from the Ubuntu systemtap-sdt-devel package, which works for both arm64 and x86.</p>

<p>C program can be as simple as:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include "sdt.h"
</span><span class='line'>int main() {
</span><span class='line'>  DTRACE_PROBE("test", "probe1");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>One compiling this, a new <code>.note.stapsdt</code> ELF section is created, which can be read by:
<code>readelf -n &lt;bin-path&gt;</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Displaying notes found in: .note.stapsdt
</span><span class='line'>  Owner                 Data size Description
</span><span class='line'>  stapsdt              0x00000029 NT_STAPSDT (SystemTap probe descriptors)
</span><span class='line'>    Provider: "test"
</span><span class='line'>    Name: "probe1"
</span><span class='line'>    Location: 0x0000000000000664, Base: 0x00000000000006f4, Semaphore: 0x0000000000000000
</span><span class='line'>    Arguments: </span></code></pre></td></tr></table></div></figure>


<p>Here there are no arguments, however we can use <code>DTRACE_PROBE2</code> to pass more, for example for 2 of them:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int main() {
</span><span class='line'>  int a = 1;
</span><span class='line'>  int b = 2;
</span><span class='line'>
</span><span class='line'>  DTRACE_PROBE2("test", "probe1", a, b);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The <code>readelf</code> tool now reads:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Displaying notes found in: .note.stapsdt
</span><span class='line'>  Owner                 Data size Description
</span><span class='line'>  stapsdt              0x00000040 NT_STAPSDT (SystemTap probe descriptors)
</span><span class='line'>    Provider: "test"
</span><span class='line'>    Name: "probe1"
</span><span class='line'>    Location: 0x0000000000000672, Base: 0x0000000000000704, Semaphore: 0x0000000000000000
</span><span class='line'>    Arguments: -4@-4(%rbp) -4@-8(%rbp)</span></code></pre></td></tr></table></div></figure>


<p>Notice how the arguments show exactly how to access the parameters at the location. In this case, we know the arguments are on the stack and at momention offsets from the base pointer.</p>

<p>Compiling with <code>-f-omit-frame-pointer</code> shows the following in <code>readelf</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Displaying notes found in: .note.stapsdt
</span><span class='line'>  Owner                 Data size Description
</span><span class='line'>  stapsdt              0x00000040 NT_STAPSDT (SystemTap probe descriptors)
</span><span class='line'>    Provider: "test"
</span><span class='line'>    Name: "probe1"
</span><span class='line'>    Location: 0x0000000000000670, Base: 0x0000000000000704, Semaphore: 0x0000000000000000
</span><span class='line'>    Arguments: -4@-4(%rsp) -4@-8(%rsp)</span></code></pre></td></tr></table></div></figure>


<p>Without the base pointer, the compiler relies on the stack pointer for the arguments. However notice that even though the C program is identical to the previous example, the &ldquo;arguments&rdquo; in the note section of the ELF has changed. This dynamic nature is one of the key reasons why SDT probes are so much better than say using <code>perf probe</code> directly to install Uprobes in the wild. With some help userspace and the compiler, we have more reliable information to access arguments without needing any DWARF debug info.</p>

<p>Compiling with ARM64 gcc shows a slightly different output for the Arguments. Note that that Arguments is just a string which can be post processed by tools to fetch the probe data.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Displaying notes found in: .note.stapsdt
</span><span class='line'>  Owner                 Data size Description
</span><span class='line'>  stapsdt              0x0000003f NT_STAPSDT (SystemTap probe descriptors)
</span><span class='line'>    Provider: "test"
</span><span class='line'>    Name: "probe1"
</span><span class='line'>    Location: 0x000000000000077c, Base: 0x0000000000000820, Semaphore: 0x0000000000000000
</span><span class='line'>    Arguments: -4@[sp, 12] -4@[sp, 8]</span></code></pre></td></tr></table></div></figure>


<p>USDT limitations as I see it:</p>

<ul>
<li><p>No information about types is stored. This is kind of sad, since now inorder to know what do with the values, one needs more information. These tracepoints were used with DTrace and SystemTap and turns out the scripts that probe these tracepoints are where the type information is stored or assumed. Uprobes tracer supports &ldquo;string&rdquo; but without knowing that the USDT is a string value, there&rsquo;s no way a Uprobe can be created on it, since all the stap note tells us is that there&rsquo;s a pointer there (who knows if its a 64-bit integer or a character pointer, for example).</p></li>
<li><p>Argument names are also not stored. This means arguments have to be in the same order in the debug script as they are in the program being debugged.</p></li>
</ul>


<p>It seems with a little bit of work, both these things can be added. Does that warrant a new section or can the stapsdt section be augment without causing breakage of existing tools? I don&rsquo;t know yet.</p>

<h2>SDT parsing logic</h2>

<p>BCC has a USDT parser written to extract probes from the ELF. Read <code>parse_stapsdt_note</code> in <code>src/cc/bcc_elf.c</code> in the BCC tree for details.</p>

<h2>Dynamic programming languages</h2>

<p>Programs that are interpretted can&rsquo;t provide this information ahead of time. The <a href="https://github.com/sthima/libstapsdt#how-it-works">libstapsdt</a> tries to solve this by <a href="https://github.com/sthima/libstapsdt/blob/6045277309ff0425322bed5e71393ce5c8fa1344/src/libstapsdt.c#L89">creating a shared library on the fly</a> and linking to it from the dynamic program. This seems a bit fragile but appears to have users. There are wrappers in Python and Nodejs. <a href="https://medium.com/sthima-insights/we-just-got-a-new-super-power-runtime-usdt-comes-to-linux-814dc47e909f">Check this article</a> for more details.</p>

<p>Open question I have:
* Do any existing Linux tools handle USDT strings? Uprobe tracer does support strings, so the infrastructure seems to be there. I didn&rsquo;t see any hints of this in <a href="src/cc/usdt/usdt_args.cc">BCC</a>. Neither does <a href="https://github.com/sthima/libstapsdt/blob/6045277309ff0425322bed5e71393ce5c8fa1344/src/libstapsdt.h#L14">libstapsdt</a> seem to have this.</p>

<h2>Other ideas</h2>

<ul>
<li><p>Creating Uprobes on the fly when a process is loaded: Ideally speaking, if the ELF note section had all the information that the kernel needed, then we could create the Uprobe events for the uprobe trace events at load time and keep them disabled without needing userspace to do anything else. This seems crude at first, but in the &ldquo;default&rdquo; case, it would still have almost no-overhead. This does mean that all the information Uprobe tracing needs will have to be stored in the note section. The other nice thing about this is, you no longer need to know the PID of all processes with USDTs in them.</p></li>
<li><p>For dynamic languages, <code>libstapsdt</code> seems great, but it feels a bit hackish since it creates a temporary file for the stub. Perhaps uprobes can be created after the temporary file is dlopen&#8217;ed and then the file can be unlinked if it hasn&rsquo;t been already, so that there aren&rsquo;t any more references to the temporary file in the file system. Such a temporary file could also probably be in a RAM based file system.</p></li>
</ul>


<h2>References</h2>

<ol>
<li><a href="http://www.brendangregg.com/blog/2015-07-03/hacking-linux-usdt-ftrace.html">Brendan Gregg&rsquo;s USDT ftrace page</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/trace/uprobetracer.txt">Uprobe tracer in the kernel</a></li>
<li><a href="https://medium.com/sthima-insights/we-just-got-a-new-super-power-runtime-usdt-comes-to-linux-814dc47e909f">USDT for dynamic languages</a></li>
<li><a href="https://dzone.com/articles/next-generation-linux-tracing">Sasha Goldstein&rsquo;s &ldquo;Next Generation Linux Tracing With BPF&rdquo; article</a></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/01/08/bpfd-bcc/">Bpfd Bcc</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2018-01-08T00:00:00-08:00" pubdate data-updated="true"></time>
        
           | <a href="/blog/2018/01/08/bpfd-bcc/#disqus_thread"
             data-disqus-identifier="http://www.linuxinternals.org/blog/2018/01/08/bpfd-bcc/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>BPFd: Running BCC tools remotely across systems and architectures</h1>

<h2>Introduction</h2>

<p><a href="https://github.com/iovisor/bcc/blob/master/README.md">BCC tools</a> are a suite of kernel tracing tools that allow systems engineers to efficiently and safely get a deep understanding into the inner workings of a Linux system. Because they can&rsquo;t crash the kernel, they are safer than kernel modules and are also can be used in production. <a href="http://www.brendangregg.com/ebpf.html">Brendan Gregg has written</a> several nice tools, and talks in videos showing the full power of eBPF based tools.</p>

<p>In the Android kernel team, we work mostly on ARM64 systems since most Android devices are on this architecture. BCC tools support on ARM64 systems had been broken for years. Recently this got <a href="https://github.com/iovisor/bcc/issues/1202">fixed</a> and one could run the tools but..</p>

<p>Inorder for BCC tools to work at all, they need kernel sources. This is because most tools need to register callbacks on the ever changing kernel API inorder to get their data. Such callbacks are registered using the <a href="https://lwn.net/Articles/132196/">kprobe</a> infrastructure. Kernel sources are large in size and often can take up a large amount of space on the system being debugged. They can also get out of sync which may make the tools misbehave.</p>

<p>The other issue is Clang and LLVM libraries need to be available on the target being traced. This is because the tools compile the needed BPF bytecode which are then loaded into the kernel. These libraries take up a lot space. It seems overkill you need a full blown compiler infrastructure on a system when the BPF code can be compiled elsewhere and maybe even compiled just once. Further these libraries need to be cross-compiled to run on the architecture you&rsquo;re tracing. That&rsquo;s possible, but why would anyone want to do that if they didn&rsquo;t need to? Cross-compiling compiler toolchains can be tedious and stressful.</p>

<h2>BPFd: A daemon for BPF code and commands</h2>

<p><a href="https://github.com/joelagnel/bpfd">Sources for BPFd can be downloaded here</a>.</p>

<p>Instead of loading up all the tools, compiler infrastructure and kernel sources onto the targets being traced, I decided to write a proxy program named BPFd that would receive commands and perform them on behalf of whoever is requesting them. The program would encapsulate all the needs of BCC and perform them &ndash; this includes loading a BPF program, creating, deleting and looking up maps, attaching a BPF program to a kprobe, polling for new data that the BPF may have written into a perf buffer etc.</p>

<h3>Simple design</h3>

<p>The design of BPFd is quite simple, it expects commands on <code>stdin</code> (standard input) and provides the results over <code>stdout</code> (standard output). Every command is only a single line always, no matter how big the command is. This allows easy testing using <code>cat</code>, since one could simply <code>cat</code> a file with commands, and parse whether the results are as expected. Results from a command however can be multiple lines.</p>

<p>For example, following is a command to BPFd for creating a BPF map:
  BPF_CREATE_MAP 1 count 8 40 10240 0</p>

<p>And the result from BPFd is:
  bpf_create_map: ret=3</p>

<p>The command tells BPFd to create a map named <code>count</code> with map type 1, with a key size of 6 bytes and a value size of 40, maximum of 10240 entries and no special flags. In return, BPFd created a map which is identified by file descriptor 3.</p>

<p>With the simple standard input/output design, its possible to write wrappers around BPFd to handle more advanced communication such as USB or Networking. In Android, we are going to be communicating these commands over the USB-based <a href="https://developer.android.com/studio/command-line/adb.html">Android Debug Bridge</a>.</p>

<h3>Changes to BCC tools</h3>

<p><a href="https://github.com/joelagnel/bcc/tree/bcc-bpfd">Branch with latest changes to BCC tools</a></p>

<p>A new <code>remotes</code> module has been added to BCC tools with an abstraction that different remote mechanisms should adhere to. This keeps code duplication to a minimum. Currently an <code>adb</code> remote and a <code>process</code> remote have been added.  The <code>adb</code> remote is for communication with the target device over USB or WiFi using the <a href="https://developer.android.com/studio/command-line/adb.html">Android Debug Bridge</a>. The <code>process</code> remote is for local testing. With this remote, BPFd is forked on the same machine running BCC and communicates with it over <code>stdin</code> and <code>stdout</code>.</p>

<p>BCC tools modifications involve the following changes:
&ndash; Adding support for remote communication with BPFd such as adb
&ndash; Changes to BCC to send commands to the remote system
&ndash; Making the kernel build more configurable so that kernel source and target architecture information can be passed through environment variables.
&ndash; Changes to tools to accomodate the differences
&ndash; Some bug fixes</p>

<h3>Installation procedure: Trying this work out for yourself!</h3>

<p>If you want to just see examples of the results of running these tools, <a href="#running-filetop">you could jump</a> straight to the tools section.
This is just an example of a typical installation procedure, it should be fairly straight forward to get these steps working for other remotes or architectures. For this example, we&rsquo;ll refer to the machine where you do all your development and have your kernel sources available as the <code>development machine</code> and the machine you&rsquo;re tracing as the <code>target</code>.</p>

<h4>Install BCC tools on your development host</h4>

<p>Follow the <a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md">steps here</a> to get BCC tools installed on your development machine.</p>

<p>Except for the following changes:
&ndash; Build BCC <a href="https://github.com/joelagnel/bcc/tree/bcc-bpfd">using this branch</a>
&ndash; Read the section &ldquo;Build LLVM and Clang development libs&rdquo; in that document. Unfortunately BPF inline-assembler support in LLVM is fairly recent, so you may need to build your own LLVM till then. Once LLVM is built, add <code>&lt;path-to-llvm-source&gt;/build/bin/</code> to your <code>$PATH</code> and then build BCC.</p>

<h4>Build/Install BPFd on your target machine</h4>

<p><a href="https://github.com/joelagnel/bpfd">Clone and build the BPFd sources.</a>. This really depends on the target distro, typically you can store it anywere <code>$PATH</code> on the target can find it, in Android we store it in <code>/data/</code> for now. In the future we&rsquo;d want to store it in /system/bin/ once its an official Android package.</p>

<h4>Prepare your kernel sources</h4>

<ul>
<li>Make sure the kernel sources are available on your development machine somewhere, and that the kernel build has completed atleast once in the kernel source directory.</li>
</ul>


<h4>Setup environment variables and run tools</h4>

<p>The following environment variables need to be setup:
&ndash; <code>ARCH</code> should point to the architecture of the <code>target</code> such as <code>x86</code> or <code>arm64</code>.
&ndash; <code>BCC_KERNEL_SOURCE</code> should point to the kernel source directory.
&ndash; <code>BCC_REMOTE</code> should point to the remote mechanism such as <code>adb</code>.</p>

<p>Two example enviornment variable settings are provided which can be sourced. Here&rsquo;s one for <a href="https://github.com/joelagnel/bcc/blob/bcc-bpfd/arm64-adb.rc">adb interface with an arm64 Android target</a> and another one for a <a href="https://github.com/joelagnel/bcc/blob/bcc-bpfd/x86-local.rc">local x86 target with a process remote</a>.</p>

<h3>BPF Demos: examples of different BCC tools running on Android</h3>

<h4>Running filetop</h4>

<p><code>filetop</code> is a BCC tool which shows you all read/write I/O operations with a similar experience to the <code>top</code> tool. In refreshes every few seconds giving you a live view of these operations.
Goto your bcc directory and set the env variables needed. For Android running on Hikey960, I run:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>joel@ubuntu:~/bcc# source arm64-adb.rc</span></code></pre></td></tr></table></div></figure>


<p>which basically sets the following environment variables:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  export ARCH=arm64
</span><span class='line'>  export BCC_KERNEL_SOURCE=/home/joel/sdb/hikey-kernel/
</span><span class='line'>  export BCC_REMOTE=adb</span></code></pre></td></tr></table></div></figure>


<p>Next I start <code>filetop</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>joel@ubuntu:~/bcc# ./tools/filetop.py 5</span></code></pre></td></tr></table></div></figure>


<p>This tells the tool to monitor file I/O every 5 seconds.</p>

<p>While <code>filetop</code> is running, I start the stock email app in Android and the output looks like:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  Tracing... Output every 5 secs. Hit Ctrl-C to end
</span><span class='line'>  13:29:25 loadavg: 0.33 0.23 0.15 2/446 2931
</span><span class='line'> 
</span><span class='line'>  TID    COMM             READS  WRITES R_Kb    W_Kb    T FILE
</span><span class='line'>  3787   Binder:2985_8    44     0      140     0       R profile.db
</span><span class='line'>  3792   m.android.email  89     0      130     0       R Email.apk
</span><span class='line'>  3813   AsyncTask #3     29     0      48      0       R EmailProvider.db
</span><span class='line'>  3808   SharedPreferenc  1      0      16      0       R AndroidMail.Main.xml
</span><span class='line'>  3811   SharedPreferenc  1      0      16      0       R UnifiedEmail.xml
</span><span class='line'>  3792   m.android.email  2      0      16      0       R deviceName
</span><span class='line'>  3815   SharedPreferenc  1      0      16      0       R MailAppProvider.xml
</span><span class='line'>  3813   AsyncTask #3     8      0      12      0       R EmailProviderBody.db
</span><span class='line'>  3809   AsyncTask #1     8      0      12      0       R suggestions.db
</span><span class='line'>  2434   WifiService      4      0      4       0       R iface_stat_fmt
</span><span class='line'>  2434   WifiService      4      0      4       0       R iface_stat_fmt
</span><span class='line'>  3792   m.android.email  66     0      2       0       R framework-res.apk</span></code></pre></td></tr></table></div></figure>


<p>Notice the Email.apk being read by Android to load the email application, and then various other reads happening related to the email app. Finally, WifiService continously reads iface_state_fmt to get network statistics for Android accounting.</p>

<h4>Running biosnoop</h4>

<p>Biosnoop is another great tool shows you block level I/O operations (bio) happening on the system along with the latency and size of the operation. Following is a sample output of running <code>tools/biosnoop.py</code> while doing random things in the Android system.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  TIME(s)        COMM           PID    DISK    T  SECTOR    BYTES   LAT(ms)
</span><span class='line'>  0.000000000    jbd2/sdd13-8   2135   sdd     W  37414248  28672      1.90
</span><span class='line'>  0.001563000    jbd2/sdd13-8   2135   sdd     W  37414304  4096       0.43
</span><span class='line'>  0.003715000    jbd2/sdd13-8   2135   sdd     R  20648736  4096       1.94
</span><span class='line'>  5.119298000    kworker/u16:1  3848   sdd     W  11968512  8192       1.72
</span><span class='line'>  5.119421000    kworker/u16:1  3848   sdd     W  20357128  4096       1.80
</span><span class='line'>  5.119443000    kworker/u16:1  3848   sdd     W  24551552  4096       1.82
</span><span class='line'>  5.119462000    kworker/u16:1  3848   sdd     W  24551680  4096       1.82
</span><span class='line'>  5.119478000    kworker/u16:1  3848   sdd     W  24617256  4096       1.83
</span><span class='line'>  5.448831000    SettingsProvid 2415   sdd     W  20648752  8192       1.70</span></code></pre></td></tr></table></div></figure>


<h4>Running hardirq</h4>

<p>This tool measures the total time taken by different hardirqs in the systems. excessive time spent in hardirq can result in poor real-time performance of the system</p>

<pre><code>joel@ubuntu:~/bcc# ./tools/hardirqs.py
</code></pre>

<p>Output:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  Tracing hard irq event time... Hit Ctrl-C to end.
</span><span class='line'>  HARDIRQ                    TOTAL_usecs
</span><span class='line'>  wl18xx                             232
</span><span class='line'>  dw-mci                            1066
</span><span class='line'>  e82c0000.mali                     8514
</span><span class='line'>  kirin                             9977
</span><span class='line'>  timer                            22384</span></code></pre></td></tr></table></div></figure>


<h4>Running biotop</h4>

<p>Run biotop while launching the android Gallery app and doing random stuff:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>joel@ubuntu:~/bcc# ./tools/biotop.py</span></code></pre></td></tr></table></div></figure>


<p>Output:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PID    COMM             D MAJ MIN DISK       I/O  Kbytes  AVGms
</span><span class='line'>4524   droid.gallery3d  R 8   48  ?           33    1744   0.51
</span><span class='line'>2135   jbd2/sdd13-8     W 8   48  ?           15     356   0.32
</span><span class='line'>4313   kworker/u16:4    W 8   48  ?           26     232   1.61
</span><span class='line'>4529   Jit thread pool  R 8   48  ?            4     184   0.27
</span><span class='line'>2135   jbd2/sdd13-8     R 8   48  ?            7      68   2.19
</span><span class='line'>2459   LazyTaskWriterT  W 8   48  ?            3      12   1.77
</span><span class='line'>2457   TaskSnapshotPer  W 8   48  ?            3      12   1.72
</span><span class='line'>4541   GLThread 152     R 8   48  ?            1       4   1.81
</span><span class='line'>4545   Error dump: sys  W 8   48  ?            1       4   1.70</span></code></pre></td></tr></table></div></figure>


<h3>Open issues as of this writing</h3>

<p>While most issues have been fixed, a few remain. Patches and testing are welcomed!
Following is an incomplete list:
&ndash; cachetop doesn&rsquo;t show hits/misses counter on arm64
&ndash; syscount reads <code>comm_for_pid</code> locally, instead of on the remote.
&ndash; Issues with stacktrace based tools:
  &ndash; offcputime on arm64 shows &ldquo;unknown&rdquo; from the stack trace.
  &ndash; getting tonnes of stack traces is still slow &ndash; possible fix is to dump entire map remotely and send it at once instead of individually sending each key/value as a separate command.</p>

<h3>Conclusion and word on similiarity to SystemTap:</h3>

<p>Building code for instrumentation on a different machine is beneficial and BPFd makes this possible. Tools like <a href="https://sourceware.org/systemtap/">SystemTap</a> have a similar feature. With SystemTap, one can build a kernel module containing the instrumentation/probing code  using the SystemTap scripting language. There&rsquo;s a <code>stap</code> command for that, and then the kernel module is copied over to the target and run using the <code>staprun</code>. However this is quite unsafe since kernel modules can crash the kernel. Further more, the stap scripting language is quite limited in comparison to the eBPF programs written in C. BCC tools are the future of such deep tracing endeavours.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/12/31/nmi-perf-armv8/">ARMv8: Flamegraph and NMI Support</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-12-31T21:29:26-08:00" pubdate data-updated="true">Dec 31<span>st</span>, 2016</time>
        
           | <a href="/blog/2016/12/31/nmi-perf-armv8/#disqus_thread"
             data-disqus-identifier="http://www.linuxinternals.org/blog/2016/12/31/nmi-perf-armv8/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Non-maskable interrupts (NMI) is a really useful feature for debugging, that hardware can provide. Unfortunately ARM doesn&rsquo;t provide an out-of-the-box NMI interrupt mechanism. This post shows a flamegraph issue due to missing NMI support, and the upstream work being done to simulate NMI in ARMv8.</p>

<p>Some great Linux kernel features that rely on NMI to work properly are:</p>

<ul>
<li><p>Backtrace from all CPUs: A number of places in the kernel rely on dumping the stacks of all CPUs at the time of a failure to determine what was going on. Some of them are <a href="http://lxr.free-electrons.com/source/kernel/hung_task.c">Hung Task detection</a>, <a href="http://lxr.free-electrons.com/source/Documentation/lockup-watchdogs.txt">Hard/soft lockup detector</a> and spinlock debugging code.</p></li>
<li><p>Perf profiling and flamegraphs: To be able to profile code that runs in interrupt handlers, or in sections of code that disable interrupts, Perf relies on NMI support in the architecture. <a href="http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html">flamegraphs</a> are a great visual representation of perf profile output. Below is a flamegraph I generated from perf profile output, that shows just what happens on an architecture like ARMv8 with missing NMI support. Perf is using maskable-interrupts on this platform for profiling:</p></li>
</ul>


<p><img src="/images/nmi/flamegraph.png"></p>

<p>As you can see in the area of the flamegraph where the arrow is pointed, a large amount of time is spent in <code>_raw_spin_unlock_irqrestore</code>. It can baffle anyone looking at this data for the first time, and make them think that most of the time is spent in the unlock function. What&rsquo;s actually happenning is because perf is using a maskable interrupt in ARMv8 to do its profiling, any section of code that disables interrupts will not be see in the flamegraph (not be profiled). In other words perf is unable to peek into sections of code where interrupts are disabled. As a result, when interrupts are reenabled during the <code>_raw_spin_unlock_irqrestore</code>, the perf interrupt routine then kicks in and records the large number of samples that elapsed in the interrupt-disable section but falsely accounts it to the _raw_spin_unlock_restore function during which the perf interrupt got a chance to run. Hence the flamegraph anomaly. It is indeed quite sad that ARM still doesn&rsquo;t have a true NMI which perf would love to make use of.</p>

<p>BUT! <a href="https://lkml.org/lkml/2016/8/19/583">Daniel Thompson</a> has been hard at work trying to simulate Non-maskable interrupts on ARMv8. The idea is <a href="/misc/arm-irq-priortization-white-paper.pdf">based on using interrupt priorities</a> and is the subject of the rest of this post.</p>

<h2>NMI Simulation using priorities</h2>

<p>To simulate an NMI, Daniel creates 2 groups of interrupts in his patchset. One group is for all &lsquo;normal&rsquo; interrupts, and the other for non-maskable interrupts (NMI). Non-maskable interrupts are assigned a higher priority than the normal interrupt group. Inorder to &lsquo;mask&rsquo; interrupts in this approach, Daniel replaces the regular interrupt masking scheme in the kernel which happens at the CPU-core level, with setting of the interrupt controller&rsquo;s PMR (priority mask register). When the PMR is set to a certain value, only interrupts which have a higher priority than what&rsquo;s in the PMR will be signaled to a CPU core, all other interrupts will be silenced (masked). By using this technique, it is possible to mask normal interrupts while keeping the NMI unmasked all the time.</p>

<p>Just how does he do this? So, a small primer on interrupts in the ARM world.
ARM uses the GIC <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dai0176c/ar01s03s01.html">Generic interrupt controller</a> to prioritize and route interrupts to CPU cores. GIC interrupt priorties go from 0 to 255. 0 being highest and 255 being the lowest. By default, the kernel <a href="http://lxr.free-electrons.com/source/include/linux/irqchip/arm-gic.h?v=4.8#L57">assigns priority 0xa0 (192)</a> to all interrupts. He changes this default priority from 0xa0 to 0xc0 (you&rsquo;ll see why).
He then defines what values of PMR would be consider as &ldquo;unmasked&rdquo; vs &ldquo;masked&rdquo;. Masked is 0xb0 and unmasked is 0xf0. This results in the following priorities (greater numbers are lower priority).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0xf0 (240 decimal)  (11110000 binary) - Interrupts Unmasked (enabled)
</span><span class='line'>0xc0 (192 decimal)  (11000000 binary) - Normal interrupt priority
</span><span class='line'>0xb0 (176 decimal)  (10110000 binary) - Interrupts masked   (disabled)
</span><span class='line'>0x80 (128 decimal)  (10000000 binary) - Non-maskable interrupts</span></code></pre></td></tr></table></div></figure>


<p>In this new scheme, when interrupts are to be masked (disabled), the PMR is set to 0xf0 and when they are unmasked (enabled), the PMR is set to 0xb0. As you can see, setting the PMR to 0xb0 indeed masks normal interrupts, because 0xb0(PMR) &lt; 0xc0(Normal), however non-maskable interrupts still stay unmasked as 0x80(NMI) &lt; 0xb0(PMR). Also notice that inorder to mask/unmask interrupts, all that needs to be done is flip bit 7 in the PMR (0xb0 &ndash;> 0xf0). Daniel largely uses Bit 7 as the mask bit in the patchset.</p>

<h2>Quirk 1: Saving of the PMR context during traps</h2>

<p>Its suggested in the patchset that during traps, the priority value set in the PMR needs to be saved because it may change during traps. To facilitate this, Daniel found a dummy bit in the PSTATE register (PSR). During any exception, Bit 7 of of the PMR is saved into a PSR bit (he calls it the G bit) and restores it on return from the exception. Look at the changes to <code>kernel_entry</code> macro in the set for this code.</p>

<h2>Quirk 2: Ack of masked interrupts</h2>

<p>Note that interrupts are masked before the GIC interrupt controller code can even identify the source of the interrupt. When the GIC code eventually runs, it is tasked with identifying the interrupt source. It does so by reading the <code>IAR</code> register. This read also has the affecting of &ldquo;Acking&rdquo; the interrupt &ndash; in other words, telling the GIC that the kernel has acknowledged the interrupt request for that particular source. Daniel points out that, because the new scheme uses PMR for interrupt masking, its no longer possible to ACK interrupts without first unmasking them (by resetting the PMR) so he temporarily resets PMR, does the <code>IAR</code> read, and restores it. Look for the code in <code>gic_read_iar_common</code> in his patchset to handle this case.</p>

<h2>Open questions I have</h2>

<ul>
<li>Where in the patchset does Daniel mask NMIs once an NMI is in progress, or is this even needed?</li>
</ul>


<h2>Future work</h2>

<p>Daniel has tested his patchset only on the foundation model yet, but it appears that the patch series with modifications should work on the newer Qualcomm chipsets that have the necessary GIC (Generic interrupt controller) access from the core to mess with IRQ priorities. Also, currently Daniel has only implemented CPU backtrace, more work needs to be done for perf support which I&rsquo;ll look into if I can get backtraces working properly on real silicon first.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2018/02/10/usdt-notes/">USDT for Reliable Userspace Event Tracing</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/01/08/bpfd-bcc/">Bpfd Bcc</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/31/nmi-perf-armv8/">ARMv8: Flamegraph and NMI Support</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/06/18/ftrace-events-mechanism/">Ftrace Events Mechanism</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/20/tif-need-resched-why-is-it-needed/">TIF_NEED_RESCHED: Why Is It Needed</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/25/tying-2-voltage-sources-slash-signals-together/">Tying 2 Voltage Sources/signals Together</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/04/a-microsd-card-remote-switcher/">MicroSD Card Remote Switch</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/07/spinlock-implementation-in-linux-kernel/">Linux Spinlock Internals</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/24/studying-cache-line-sharing-effects-on-smp-systems/">Studying Cache-line Sharing Effects on SMP Systems</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/22/design-of-fork-followed-by-exec-in-linux/">Design of Fork Followed by Exec in Linux</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2018 - Joel Fernandes -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'linuxinternals1';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
